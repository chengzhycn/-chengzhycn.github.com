---
layout: post
title:  "RubyProgramming CH5"
date:   2015-10-15 21:54:00
categories: Ruby
excerpt: study notes about RubyProgramming
---

* content
{:toc}


## 数字
---
*   进制指示前导符号：0表示八进制，0x表示16进制，0b表示二进制。
*   下划线在数字串中被忽视(可以在一些比较大的数值中代替逗号)。
*   整数支持几种有用的迭代器，times，upto，downto，step是常用的几种。

        1.9.3-p551 :298 > 4.times {print "x"}
        xxxx => 4 
        1.9.3-p551 :300 > 1.upto(5) {|i| print i, " "}
        1 2 3 4 5  => 1 
        1.9.3-p551 :301 > 5.downto(1) {|i| print i, " "}
        5 4 3 2 1  => 5 
        1.9.3-p551 :302 > 50.step(80, 5) {|i| print i, " "}
        50 55 60 65 70 75 80  => 50 

*   只包含数字的字符串，并不会自动转换成数字。所以从文件中读取时常常会出现问题。我们可以使用Integer方法把字符串转换成整数来解决这个问题。

## 字符串
---
*   前面说过，字符串分界符决定了字符串里要被替换的程度。在单引号字符串中，两个连续的反斜线会被一个反斜线替换，而后面跟有一个单引号的反斜线变成一个单引号。
*   而双引号字符串支持更多的转义序列。最重要的是可以使用#{expr}将任何Ruby代码的值放进字符串中。如果代码只是全局变量、类变量、实例变量的话，花括号可以忽略。

        2.2.1 :001 > a = 'escape using "\\"'
         => "escape using \"\\\"" 
        2.2.1 :002 > puts '#{a}'
        #{a}
         => nil 
        2.2.1 :003 > puts "#{a}"
        escape using "\"
         => nil 
        2.2.1 :010 > d =  %q<    he<faf>faf>
         => "    he<faf>faf" 


*   除了上述两种还有另外三种方法去构建字符串字面量。
*   %q和%Q分别开始界定单引号和双引号的字符串，跟在q或者Q后面的字符是分界符。分界符可以是任意一个非数字字母的单字节字符。字符串会一直被读取直到遇到下一个相同的分界符。如果分界符是开始于"[" "{" "<" "("，那么字符串会一直读取直到发现相匹配的结束符号。
*   最后，还可以使用here document构建字符串。

        2.2.1 :011 > f = <<END_OF_STRING
        2.2.1 :012"> The body of the string
        2.2.1 :013"> is the input lines up to
        2.2.1 :014"> one ending with the same
        2.2.1 :015"> text that followed the '<<'
        2.2.1 :016"> END_OF_STRING
         => "The body of the string\nis the input lines up to\none ending with the same\ntext that followed the '<<'\n" 

*   here document由源文件中包含在<<字符后面的终结字符串中的字符串组成。如果把一个减号放在<<后面，就可以缩进编排终结符。
    
        2.2.1 :017 > print <<-STRING1, <<-STRING2
        2.2.1 :018"> Hello
        2.2.1 :019"> STRING1
        2.2.1 :020"> World!
        2.2.1 :021"> STRING2
        Hello
        World!
         => nil 

*   **ps：文件中使用here document貌似还有点问题，暂时还没解决...=.=!!**

## 区间
---
*   Ruby中区间(Ranges)可以实现3种不同的特性：序列(sequences)、条件(conditional)和间隔(intervals)。

### 区间作为序列
---
*   使用".."和"..."区间操作符来创建序列。两个点的形式是创建闭合的区间，而三个点的形式是创建半开半闭的区间(不包括右端的值)。
*   区间在内部没有用列表(list)表示，1..1000序列被存储为Range对象，它包含两个Fixnum
*   对象的引用。

        2.2.1 :022 > (1..10).to_a
         => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
        2.2.1 :023 > ran = 1..10
         => 1..10 
        2.2.1 :024 > ran.include?(5)
         => true 
        2.2.1 :025 > ran.min
         => 1 
        2.2.1 :026 > ran.max
         => 10 
        2.2.1 :027 > ran.reject { |i| i>6}
         => [1, 2, 3, 4, 5, 6] 

*   Ruby还可以根据你所定义的对象来创建区间。唯一的限制是这些对象必须返回在序列中的下一个对象作为对succ的响应，而且这些对象必须是可以使用<=>来比较的。
*   <=>也被称作太空船(spaceship)操作符，它比较两个值，并根据第一个值是否小于、等于或大于第二个值，分别返回-1，0或+1。

### 区间作为条件
---
*   作为条件时，当区间的第一部分条件为true时，它们就打开，当第二部分条件为真时，它们就关闭。

### 区间作为间隔
*   区间最后一种用法是用作间隔测试：看看一些值是否会落入区间表达的间隔内。使用===即case equality操作符可以做到这一点。

        2.2.1 :030 > (1..10) ===5
         => true 
        2.2.1 :031 > ('a'...'j') === 'h'
         => true 
        2.2.1 :032 > ('a'...'j') === 'z'
         => false 

## 正则表达式
---
*   在第二章里说到，正则表达式是Regexp类型的对象。可以通过显式地调用构造函数或者使用字面量形式/pattern/和%r{pattern}来创建它们。

        2.2.1 :001 > a = Regexp.new('^\s*[a-z]')
         => /^\s*[a-z]/ 
        2.2.1 :002 > b = /^\s*[a-z]/
         => /^\s*[a-z]/ 
        2.2.1 :003 > c = %r{^\s*[a-z]}
         => /^\s*[a-z]/ 
*   匹配操作符会返回匹配发生的字符位置，同时，也会设置一些字符变量。$&得到与模式匹配的那部分字符串，$`得到匹配之前的那部分字符串，而$'得到匹配之后的那部分字符串。

        2.2.1 :004 > def show_regexp(a, re)
        2.2.1 :005?>   if a =~ re
        2.2.1 :006?>     "#{$`}<<#{$&}>>#{$'}"
        2.2.1 :007?>     else
        2.2.1 :008 >       "not match"
        2.2.1 :009?>   end
        2.2.1 :010?> end
         => :show_regexp 
        2.2.1 :011 > show_regexp('helloworld', /e/)
         => "h<<e>>lloworld" 
        2.2.1 :012 > show_regexp('helloworld', /l/)
         => "he<<l>>loworld" 

*   这个匹配也设置了线程局部变量(thread-local variables)，$~与$1直到$9(说后面再讲...)。

### 模式
---
*   每个正则表达式都包含了一种模式(patterns)，用来对字符串进行正则表达式匹配。
*   在模式内，除了.， \|， (， )， [， ]， {， }， +， \， ^， $， * ， ?字符以外，所有字符均匹配它们本身。
*   在这些字符前面放着一个反斜线便可以匹配它们的字面量。

#### 锚点
---
*   默认情况下，正则表达式会试图发现模式在字符串中出现的第一个匹配。
*  ^和$模式分别匹配行首和行尾，它们常用来锚定(anchor)模式匹配。\A序列匹配字符串的开始，而\z和\Z匹配字符串的结尾；\b匹配词的边界，\B匹配非词的边界。组词字符可以是字母，数字和下划线。(只有字符串以\n结尾\A才会匹配)
        
        2.2.1 :013 > show_regexp("this is\nthe time", /^th/)
         => "<<th>>is is\nthe time" 
        2.2.1 :018 > show_regexp("this is\nthe time", /time$/)
         => "this is\nthe <<time>>" 
        2.2.1 :019 > show_regexp("this is\nthe time", /\Athis/)
         => "<<this>> is\nthe time" 
        2.2.1 :021 > show_regexp("this is\nthe time", /\Athe/)
         => "not match" 
        2.2.1 :022 > show_regexp("this is\nthe time", /\ztime/)
         => "not match" 
        2.2.1 :023 > show_regexp("this is\nthe time", /\zis/)
         => "not match" 
        2.2.1 :024 > show_regexp("this is\nthe time", /\Zis/)
         => "not match" 
        2.2.1 :025 > show_regexp("this is\nthe time", /\Ztime/)
         => "not match" 
        2.2.1 :026 > show_regexp("this is\nthe time", /\bis/)
         => "this <<is>>\nthe time" 
        2.2.1 :027 > show_regexp("this is\nthe time", /\Bis/)
         => "th<<is>> is\nthe time" 

*   **PS:\z和\Z匹配不出来，待解决...???**

#### 字符类
---
*   字符类是处于方括号之间字符的集合：[characters]匹配方括号之间的任意单个字符。特殊正则表达式字符的意义在方括号里面的意义是关闭的。但是正常的字符串替换仍然会发生。
*   在方括号内$c_1$ - $c_2$序列表达$c_1$和c_2$之间的所有字符，并包含$c_2$。
*   如果想在字符类包含字面量字符]和-，它们必须出现在开始处。把^直接放在开始的方括号后面会对字符类求反：[^a-z]匹配任何非小写字母的字符。
*   出现在方括号外面的点号(.)表示除回车换行符之外的任何字符(在多行模式下也匹配回车换行符)。

#### 重复
---
*   如果r代表模式内先前的正则表达式，那么
    -   r* 匹配零个或者多个r的出现
    -   r+ 匹配一个或者多个r的出现
    -   r? 匹配零个或者一个r的出现
    -   r{m, n} 匹配至少m次和至多n次r的出现
    -   r{m, } 匹配至少m次的r出现
    -   r{m} 只匹配m次r的出现
*   默认情况下正则表达式会匹配尽可能多的字符串，这种模式被称作贪心(greedy)模式。我们可以通过添加问号后缀的方式让它们匹配最少的字符串来改变这个默认行为。

#### 替换
---
*   未转义的竖线(\|)表示要么是匹配它之前的表达式，要么是匹配它之后的表达式。

#### 编组
---
*   在正则表达式内使用括号编组项目，组内的所有东西被当作单个正则表达式对待。
*   括号也收集模式匹配的结果。Ruby计算开始括号的数目，保存每个开始括号和相应的关闭括号之间的部分匹配的结果。在模式内部，\1序列是指第一个组的匹配，\2序列是指第二个组的匹配。在模式外面，$1和$2等起到相同的作用。

### 基于模式的替换
---
*   之前介绍了sub方法和gsub方法替换字符串。这两个方法的第二个参数还可以是String或者block。如果使用block，匹配的字符串会传递给block，同时block的结果值会被替换到原先的字符串中。
*   替换中一些反斜线序列也起作用：\n(n为数字，表示至今为止第n个匹配的组)，\&(最后的匹配)，\\\+(最后匹配的组)，\\\`(匹配之前的字符串)，\\\'(匹配之后的字符串)，和\\\\(字面量反斜线)。

        2.2.1 :025 > str = 'a\b\c'
         => "a\\b\\c" 
        2.2.1 :026 > str.gsub(/\\/, '\&\&')
         => "a\\\\b\\\\c" 
        2.2.1 :027 > str = 'a\b\c'
         => "a\\b\\c" 
        2.2.1 :028 > str.gsub(/\\/, '\&')
         => "a\\b\\c" 
