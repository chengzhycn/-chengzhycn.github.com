---
layout: post
title:  "RubyProgramming CH4"
date:   2015-10-10 21:54:00
categories: Ruby
excerpt: study notes about RubyProgramming
---

* content
{:toc}


## 容器
---
*   所谓容器(container)，是指含有一个或多个对象引用的对象。
*   常用的容器有数组(array)，散列表(hash)。

### 数组
---
*   创建数组既可以通过字面量赋值，也可以通过显式地创建Array对象。

        1.9.3-p551 :224 > a = []
         => [] 
        1.9.3-p551 :225 > a.class
         => Array 
        1.9.3-p551 :227 > b = Array.new
         => [] 
        1.9.3-p551 :228 > b.class
         => Array 

*   数组用[]操作符来进行索引。实际上，它是Array类中的一个实例方法，因此可以被子类重载。
*   数组下标从0开始，如果访问位置上没有对象，返回nil。使用负整数访问数组，则从数组末端开始计数。
*   也可以使用[start, count]一对数字来访问数组。这将返回一个包含从start开始的count个对象引用的新数组。
*   还可以使用range来对数组进行索引，其开始位置和结束位置用两个点或者三个点分割开，两个点的形式包含结束位置，三个点的形式不包含。

        1.9.3-p551 :229 > a = [1, 2, 3, 4, 5]
         => [1, 2, 3, 4, 5] 
        1.9.3-p551 :230 > a[2]
         => 3 
        1.9.3-p551 :231 > a[10]
         => nil 
        1.9.3-p551 :232 > a[1, 3]
         => [2, 3, 4] 
        1.9.3-p551 :233 > a[-2]
         => 4 
        1.9.3-p551 :235 > a[1 .. -2]
         => [2, 3, 4] 
        1.9.3-p551 :236 > a[1 ... -2]
         => [2, 3] 

*   []操作符有一个对应的[]=操作符，它用来设置数组中的元素。如果下标是单个整数，那么其位置上的元素将被赋值语句右端的东西所替换，造成的任何空隙将由nil填充。
*   如果[]=的下标是两个数字(起点和长度)或者是range，那么原数组中的那些元素将被赋值语句右边的东西所替换。如果长度为0，那么赋值语句右边的东西将被**插入到数组的起点位置之前，且不会删除任何元素**。
*   如果右边本身是一个数组，那么其元素将替换掉原数组对应位置上的东西。如果索引下标选择的元素个数和赋值语句右边的元素个数不一致，那么数组会自动调整大小。

        1.9.3-p551 :237 > a
         => [1, 2, 3, 4, 5] 
        1.9.3-p551 :238 > a[2] = 'hello'
         => "hello" 
        1.9.3-p551 :239 > a
         => [1, 2, "hello", 4, 5] 
        1.9.3-p551 :240 > a[3] = [34, 5]
         => [34, 5] 
        1.9.3-p551 :241 > a
         => [1, 2, "hello", [34, 5], 5] 
        1.9.3-p551 :242 > a[2, 2] = 'world'
         => "world" 
        1.9.3-p551 :243 > a
         => [1, 2, "world", 5] 
        1.9.3-p551 :244 > a[2, 0] = 'just'
         => "just" 
        1.9.3-p551 :245 > a
         => [1, 2, "just", "world", 5] 
        1.9.3-p551 :246 > a[1, 1] = [9, 34, 5]
         => [9, 34, 5] 
        1.9.3-p551 :247 > a
         => [1, 9, 34, 5, "just", "world", 5] 
        1.9.3-p551 :248 > a[5..6] = 99, 98
         => [99, 98] 
        1.9.3-p551 :249 > a
         => [1, 9, 34, 5, "just", 99, 98] 
        1.9.3-p551 :250 > a[5..6]=[]
         => [] 
        1.9.3-p551 :251 > a
         => [1, 9, 34, 5, "just"] 
        1.9.3-p551 :252 > a[7...9] = 43, 55
         => [43, 55] 
        1.9.3-p551 :253 > a
         => [1, 9, 34, 5, "just", nil, nil, 43, 55] 

*   我们可以使用数组来实现栈(stack)、收集(set)、队列(queue)、双向队列(dequeue)和先进先出队列(fifo)。

### 散列表
---
*   数组使用整数进行索引，而散列表(hash)可以使用任何类型的对象进行索引。
*   当你将一个值存入hash时，需要提供两个对象，一个是索引(键 key),另一个是值。然后就可以通过键去索引值。
*   hash的字母符号表示法：处于花括号之间的key => value 键值对。

        1.9.3-p551 :254 > h = { 'hello' => 'world', 'array' => 'hash' }
         => {"hello"=>"world", "array"=>"hash"} 
        1.9.3-p551 :256 > h.length
         => 2 
        1.9.3-p551 :257 > h['hello']
         => "world" 
        1.9.3-p551 :258 > h['hello'] = 'programming'
         => "programming" 
        1.9.3-p551 :259 > h['hello']
         => "programming" 
        1.9.3-p551 :260 > h[12] = 'Ruby'
         => "Ruby" 
        1.9.3-p551 :263 > h
         => {"hello"=>"programming", "array"=>"hash", 12=>"Ruby"} 

## Blocks和迭代器
---
*   基本概念见CH2。

### 实现迭代器
---
*   常见的迭代器有find，each和collect。
*   find方法请求数组中的每一个元素并对其执行一个测试，返回的是block里条件为真的第一个值。

        1.9.3-p551 :280 > a
         => [1, 9, 34, 5, "just", 55, 43, 55] 
        1.9.3-p551 :281 > a.find {|v| v*v >50}
         => 9 
       
*   each方法连续访问收集的所有元素。**(返回值是原数组???...)**

        1.9.3-p551 :282 > a.each {|i| puts i}
        1
        9
        34
        5
        just
        55
        43
        55
         => [1, 9, 34, 5, "just", 55, 43, 55] 

*   collect方法从收集中获得各个元素并传递给block。block返回的结果被用来生成一个新的数组。

        1.9.3-p551 :283 > a.collect {|i| i.succ}
         => [2, 10, 35, 6, "jusu", 56, 44, 56] 

*   succ方法作用是返回下一个字符串。所谓的"下一个"是指按照26个字母顺序表和10进制数的顺序继续向下数时得到的结果，**不考虑负号。**在区间那部分还会继续讲到。
*   另外在Enumerable模块中还有一个比较有用的迭代器——inject，可以让你遍历收集每一个成员以累计出一个值。

        1.9.3-p551 :288 > a
         => [1, 9, 34, 5, 55, 43, 55] 
        1.9.3-p551 :289 > a.inject(0) {|sum, element| sum +element}
         => 202 

*   inject的工作方式是：block第一次被执行时，sum被置为inject的参数，而element被置为收集的第一个元素。接下来每次调用block时，sum被置为上次block被调用时的返回值。另外，如果inject没有参数，那么将会使用收集的第一个元素作为初始值，并从第二个元素开始迭代。


        1.9.3-p551 :290 > a.inject {|sum, element| sum +element}
         => 202 

*   block在代码中只和方法调用一起出现；block和方法调用的最后一个参数处于同一行并紧跟在其后(或者参数列表的右括号的后面)。
*   在遇到block的时候并不立即执行其中的代码。Ruby会记住block出现的上下文(局部变量和当前对象等)然后执行方法调用。
*   在方法内部，block可以被yield语句调用。当block结束时，控制返回到紧随yield之后的那条语句。**这也是迭代器得以实现的主要原因**。
*   在block定义中，参数列表位于两个竖线(管道符)之间。

### 内迭代器和外迭代器
---
*   在Ruby中，迭代器只不过是一个方法，它集成于收集的内部，和其它方法不同的是，每次产生新值的时候会调用yield。使用迭代器的不过是和该方法相关联的一个代码block而已。
*   当需要把迭代器本身作为一个对象的时候(例如，将迭代器传递给一个方法，该方法需要访问迭代器返回的每一个值)，Ruby的内部迭代器的表现就不尽如人意。同时，它也难以实现并行的两个收集。
*   Ruby的Generator库为解决这些问题实现了外部迭代器。

### 事务Blocks
---
*   block 可以用来定义必须运行在事务控制环境下的代码。比如，对文件内容进行处理时，需要确保在处理完之后关闭文件。传统的方法是处理完之后加上f.close函数。但这样关闭文件的责任在使用者上面。我们使用block定义新的方法，在yield后面加上关闭函数让这种责任转移到了文件本身。

        1.9.3-p551 :291 > class File
        1.9.3-p551 :292?>   def File.open_and_process(*args)
        1.9.3-p551 :293?>     f=File.open(*args)
        1.9.3-p551 :294?>     yield f
        1.9.3-p551 :295?>     f.close()
        1.9.3-p551 :296?>   end
        1.9.3-p551 :297?> end

*   在Ruby中，File.open有两种不同的行为：当和block一起调用的时候，它会执行block并关闭文件；当单独调用时，它会返回文件对象。

### Blocks作为闭包
---
*   block即使被定义的环境消失了，仍然可以使用其原始作用域的信息，这种特性被称作为闭包(closure)。
*   如果定义方法时在最后一个参数前面加上一个&，那么在调用该方法时，Ruby会尝试去寻找一个block。block将会被转化为一个proc对象，并赋值给参数。
*   当创建了proc对象时，和block关联在一起的定义block时的上下文，即self的值，作用域内的方法、变量和常量均得以保留，即实现了闭包。